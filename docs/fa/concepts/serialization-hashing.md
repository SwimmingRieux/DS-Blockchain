# سریالی‌سازی و هش کردن

سریالی‌سازی و هش کردن دو مفهوم بسیار مهم در فناوری بلاکچین هستند. آنها بنیادی هستند که یکپارچگی و سازگاری دفتر کل توزیع‌شده بر آن بنا شده است.

-   **سریالی‌سازی** فرآیند تبدیل یک ساختار داده، مانند یک بلاک یا یک تراکنش، به فرمتی است که به راحتی قابل ذخیره یا انتقال باشد. در بلاکچین، بسیار مهم است که همه شرکت‌کنندگان در شبکه، داده‌ها را دقیقاً به یک روش سریالی‌سازی کنند تا اطمینان حاصل شود که همه آنها هش یکسانی را دریافت می‌کنند.
-   **هش کردن** فرآیند دریافت ورودی با هر اندازه‌ای و تولید خروجی با اندازه ثابت است که به عنوان هش شناخته می‌شود. این فرآیند یک‌طرفه است، به این معنی که معکوس کردن آن از نظر محاسباتی غیرممکن است. در بلاکچین، هش کردن برای ایجاد شناسه‌های منحصر به فرد برای بلاک‌ها و تراکنش‌ها و برای اطمینان از یکپارچگی داده‌ها استفاده می‌شود.

## سریالی‌سازی

برای اطمینان از اینکه همه گره‌ها در شبکه می‌توانند در مورد وضعیت بلاکچین به توافق برسند، باید مجموعه‌ای دقیق از قوانین برای نحوه سریالی‌سازی داده‌ها وجود داشته باشد. در این پروژه، ما از قوانین زیر استفاده خواهیم کرد:

-   **ترتیب فیلدها:** فیلدهای یک ساختار داده باید دقیقاً به ترتیبی که مستند شده‌اند، سریالی‌سازی شوند.
-   **رمزگذاری:** همه رشته‌ها باید با استفاده از UTF-8 رمزگذاری شوند و همه اعداد باید در قالب big-endian رمزگذاری شوند. به صورت جایگزین، می‌توان از یک طرح استانداردسازی JSON سازگار استفاده کرد.

### پیش‌تصویر امضای تراکنش

هنگام ایجاد یک امضای دیجیتال برای یک تراکنش، ما کل داده‌های تراکنش را امضا نمی‌کنیم. در عوض، ما زیرمجموعه خاصی از داده‌ها را که **پیش‌تصویر تراکنش** نامیده می‌شود، امضا می‌کنیم. این برای جلوگیری از وابستگی دایره‌ای است که در آن امضا باید بخشی از داده‌های در حال امضا باشد.

پیش‌تصویر فقط شامل مراجع ورودی (`prevTxId` و `prevOutIndex`) و خروجی‌ها (`value` و `publicKey`) است. فیلدهای امضا در ورودی‌ها خالی گذاشته می‌شوند.

```
preimage = serialize({
  inputs:  [{ prevTxId, prevOutIndex }],
  outputs: [{ value, publicKey }]
})
```

## هش کردن

هنگامی که یک ساختار داده سریالی‌سازی شد، می‌توان آن را هش کرد تا یک شناسه منحصر به فرد و با اندازه ثابت تولید شود.

### شناسه تراکنش (txid)

`txid` شناسه منحصر به فرد برای یک تراکنش است. این با هش کردن کل داده‌های تراکنش سریالی‌سازی شده، از جمله امضاهای دیجیتال، محاسبه می‌شود.

`txid = Hash(serialize(full transaction))`

### هش بلاک

`blockHash` شناسه منحصر به فرد برای یک بلاک است. این با هش کردن هدر بلاک سریالی‌سازی شده محاسبه می‌شود.

`blockHash = Hash(serialize(header))`

هدر بلاک شامل فیلدهای زیر است (برای بلاک جنسیس، `prevBlockHash` یک رشته از 64 صفر است):

-   `prevBlockHash`
-   `merkleRoot`
-   `difficulty`
-   `nonce`

برای تمام عملیات هش کردن در این پروژه، شما باید به طور مداوم از یک تابع هش واحد، مانند SHA-256، استفاده کنید.

## مدل اندازه داده

برای انتخاب تراکنش‌ها برای یک بلاک جدید، ماینر باید اندازه هر تراکنش را بداند تا اطمینان حاصل کند که اندازه کل بلاک از حد 2000 بایت تجاوز نمی‌کند. اندازه یک تراکنش مجموع اندازه‌های فیلدهای آن است.

در اینجا جدولی از اندازه‌های فیلد مورد استفاده در این پروژه آورده شده است:

| فیلد             | اندازه (بایت) |
| ----------------- | :----------: |
| هش              |      32      |
| ایندکس (خروجی)    |      4       |
| مقدار             |      8       |
| کلید عمومی (فشرده) |      33      |
| امضا         |      64      |

### محاسبه مثال

بیایید اندازه یک تراکنش معمولی با یک ورودی و دو خروجی را محاسبه کنیم:

-   **ورودی:** `prevTxId` (32) + `prevOutIndex` (4) + `publicKey` (33) + `signature` (64) = 133 بایت
-   **خروجی‌ها:** 2 * (`value` (8) + `publicKey` (33)) = 82 بایت
-   **کل:** 133 + 82 = 215 بایت (به علاوه چند بایت برای شمارنده‌ها/سربار)

اکنون، بیایید اندازه یک بلاک با یک هدر، یک تراکنش کوین‌بیس و نه تراکنش معمولی را در نظر بگیریم:

-   **هدر:** `prevBlockHash` (32) + `merkleRoot` (32) + `difficulty` (1) + `nonce` (4) = 69 بایت
-   **تراکنش کوین‌بیس:** 1 ورودی ساختگی (36) + 1 خروجی (41) = 77 بایت (به علاوه سربار)
-   **9 تراکنش:** 9 * 215 = 1935 بایت
-   **کل:** 69 + 77 + 1935 = 2081 بایت

این مجموع از حد 2000 بایت برای اندازه بلاک تجاوز می‌کند، که نشان می‌دهد یک ماینر باید هنگام انتخاب تراکنش‌ها برای گنجاندن در یک بلاک دقت کند.

## چرا این مهم است

قوانین دقیق برای سریالی‌سازی و هش کردن چیزی است که بلاکچین را امن و تغییرناپذیر می‌کند. هر تغییر کوچکی در داده‌های یک بلاک یا تراکنش منجر به هش کاملاً متفاوتی می‌شود. این امر تشخیص هرگونه دستکاری در داده‌ها را آسان می‌کند و یک بلوک ساختمانی اساسی برای ویژگی‌هایی مانند اثبات مرکل است.

---
[← بازگشت: امضاهای دیجیتال و پیش‌تصویر تراکنش](signatures-preimage.md) · [بعدی: واژه‌نامه →](glossary.md)